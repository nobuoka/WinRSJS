/// <reference path="..\ts-definitions\mocha.d.ts" />

// ===============================================================================
//  Microsoft patterns & practices
//  Hilo JS Guidance
// ===============================================================================
//  Copyright © Microsoft Corporation.  All rights reserved.
//  This code released under the terms of the 
//  Microsoft patterns & practices license (http://hilojs.codeplex.com/license)
// ===============================================================================

module App.Test {
    export class SpecRunner {
        appFolder: Windows.Storage.StorageFolder;
        specFolder: string;
        helperFolder: string;
        srcFolder: string;

        // eventMixin
        dispatchEvent(type: string, eventProperties: any): boolean { throw "Must be override."; }
        addEventListener(type: string, listener: Function, useCapture?: boolean): void { throw "Must be override."; }
        removeEventListener(type: string, listener: Function, useCapture?: boolean): void { throw "Must be override."; }

        constructor(options: { specs?: string; helpers?: string; src?: string; }) {
            this.specFolder = options.specs || "specs";
            this.helperFolder = options.helpers || "specs/helpers";
            this.srcFolder = options.src || "src";
        }

        // We're using the [bdd syntax][1] for Mocha, and
        // using [Chai.js][2] for the `expect` style assertions.
        //
        // [1]: http://visionmedia.github.com/mocha/
        // [2]: http://chaijs.com/
        //
        configureMocha() {
            mocha.setup("bdd");
        }

        // Run the specs for this system by finding all of the
        // needed .js files for the source code, the helper files,
        // and the specs. Inject a `<script>` tag in to the DOM
        // for each file that it finds, and then start the test
        // runner.
        run() {
            this.appFolder = Windows.ApplicationModel.Package.current.installedLocation;
            this.configureMocha();

            WinJS.Promise.wrap()
                //.then(() => this.injectHelpers())
                //.then(() => this.injectPageControls())
                .then(() => this.injectSpecList())
                .then(() => this.startTestHarness())
                .done(null, (err) => { this.triggerError(err) });
        }

        // If an error occurred, dispatch it so that the
        // app running the tests can handle it and show the
        // error message.
        triggerError(error: Error) {
            this.dispatchEvent("error", error);
        }

        startTestHarness() {
            mocha.run();
        }

        /*
        // Locate the .js files for the application via
        // the `src` folder, and inject them in to the DOM
        injectPageControls() {
            return this.getFolder(this.srcFolder)
                .then(this.getJSFileNames.bind(this))
                .then(this.buildScriptTags.bind(this))
                .then(this.addScriptsToBody.bind(this));
        }

        // Locate the .js helper files from the `helpers`
        // folder and inject them in to the DOM
        injectHelpers() {
            return this.getFolder(this.helperFolder)
                .then(this.getJSFileNames.bind(this))
                .then(this.buildScriptTags.bind(this))
                .then(this.addScriptsToBody.bind(this));
        }
        */

        // Location the *spec.js files for the specs that
        // test the application files, from the `specs`
        // folder and inject them in to the DOM
        injectSpecList() {
            return this.getFolder(this.specFolder)
                .then((folder) => this.getSpecFileNames(folder))
                .then((files) => this.buildScriptTags(files))
                .then((scriptTags) => this.addScriptsToBody(scriptTags));
        }

        // A recursive function that returns a [StorageFolder][3]
        // based on a `folder/name/` parameter. 
        //
        // Since the built in [getFolderAsync][4] method won't allow
        // a `/` in the folder to load, relative paths cannot
        // be loaded without recursion.
        //
        // [3]: http://msdn.microsoft.com/library/windows/apps/BR227230
        // [4]: http://msdn.microsoft.com/en-us/library/windows/apps/windows.storage.storagefolder.getfolderasync.aspx
        //
        getFolder(folderName: string, parentFolder?: Windows.Storage.StorageFolder): Windows.Foundation.IPromise<Windows.Storage.StorageFolder> {
            parentFolder = parentFolder || this.appFolder;

            var names = folderName.split("/");
            var name = names.shift();

            var folder = parentFolder.getFolderAsync(name);
            if (names.length === 0) {

                // Found the final folder. Return it.
                return folder;

            } else {

                // More folders to find. Recursively load them.
                return folder.then((newParent) => {
                    return this.getFolder(names.join("/"), newParent);
                });

            }
        }

        // Use a regex to find all *.js files in the specified folder,
        // including all sub-folders.
        getJSFileNames(folder: Windows.Storage.StorageFolder) {
            var nameTest = /.*js$/;
            return this._buildFileListFromRegex(nameTest, folder);
        }

        // Use a regex to find all *spec.js files in the specified folder,
        // including all sub-folders.
        getSpecFileNames(folder: Windows.Storage.StorageFolder) {
            var specTest = /spec\.js$/i;
            return this._buildFileListFromRegex(specTest, folder);
        }

        // Build a `<script>` tag array from an array of [StorageFile][5]
        // objects.
        //
        // [5]: http://msdn.microsoft.com/en-us/library/windows/apps/windows.storage.storagefile.aspx
        buildScriptTags(fileList: Windows.Storage.StorageFile[]) {
            var appPath = this.appFolder.path;

            var specList = fileList.map((file) => {
                var filePath = file.path.replace(appPath, "");
                filePath = filePath.replace(/\\/g, "/");
                var scriptEl = document.createElement("script");
                scriptEl.setAttribute("src", filePath);

                return scriptEl;
            });

            return <Windows.Foundation.IPromise<HTMLScriptElement[]>>WinJS.Promise.as(specList);
        }

        // Inject the `<script>` tag array, an array of DOM elements,
        // in to the DOM, at the bottom of the `<body>` tag.
        addScriptsToBody(scriptTags: HTMLScriptElement[]) {
            var body = document.querySelector("body");
            var scriptLoadPromises: Windows.Foundation.IPromise<void>[] = [];
            scriptTags.forEach((tag) => {
                var s = <HTMLScriptElement>body.appendChild(tag);
                scriptLoadPromises.push(new WinJS.Promise<void>((onSuccess) => {
                    s.onload = (e) => {
                        onSuccess();
                    };
                }));
            });

            return WinJS.Promise.join(scriptLoadPromises);
        }

        // Build a list of files from a folder, using the supplied
        // regex to determine if the file should be included in the
        // resulting list. Files are loaded from nested sub-folders,
        // ordered by file name.
        _buildFileListFromRegex(regEx: RegExp, folder: Windows.Storage.StorageFolder): Windows.Foundation.IPromise<Windows.Storage.StorageFile[]> {
            var fileQuery = folder.getFilesAsync(Windows.Storage.Search.CommonFileQuery.orderByName);

            return fileQuery.then(function (files) {
                var fileList = files.filter(file => regEx.test(file.name));
                return <Windows.Foundation.IPromise<Windows.Storage.StorageFile[]>>WinJS.Promise.as(fileList);
            });
        }
    }
    WinJS.Class.mix(SpecRunner, WinJS.Utilities.eventMixin);
}
